#include <bits/stdc++.h>
/*
   @ 编写Solution :  5538.h
   @ 主函数入口    :  main.cpp
   @ Author      :  Vodka
   @ Time        :  20-10-11 下午11:36 
*/
using namespace std;

class Solution {
public:

};


/*  解决思路 & 复杂度
 考虑到n≤15（看到状态有限集合、看到数比较小->状态压缩dp），可以考虑使用状态压缩来完成本题。
 节点编号0base [0, n-1]。然后设dp[k]表示k所对应的二进制状态所代表的子集的最大距离。
 例如，k=5=101(二进制)，就代表0号和2号节点组成的子集。

 由于某些节点子集并不能构成一棵子树（因为不连通），因此对于这样的子集，我们标记 dp[k]=∞。

 对于如何判断一个子集k是否能够构成一棵子树。对每一个k，逐一检查i=0~(n-1)是不是这个子树的邻接边。
 如果是邻接边，那么这个子树中必然存在一个节点j，使得dist[i][j]=1。
 此时，只用对目前加进来的这个点i和子树中的每一个节点求距离最大值即可。
 由于两点数量<=15，可以直接Floyd算出所有点对的距离。
*/

/*  Main函数入口

*/